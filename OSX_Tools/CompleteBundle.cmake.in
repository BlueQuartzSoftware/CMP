# -----------------------------------------------------------------------------------
# This file was auto generated from the template file "CompleteBundle.cmake.in", if you 
# need to make changes edit the template file NOT this one. Your changes will be 
# lost the next time CMake is run. You have been warned.
#   This file is called from CMake's installation generated scripts. It is added
# via a CMake call 
#   install(SCRIPT "${OSX_MAKE_STANDALONE_BUNDLE_CMAKE_SCRIPT}")
# which can be sometime found in the macro 'MakeOSXBundleApp' which is sometimes located
# in the file OSX_BundleTools.cmake
# -----------------------------------------------------------------------------------

message (STATUS "#------------ Starting OS X Bundle Fixup --------------------------")
cmake_minimum_required(VERSION 2.6)

#-- Need this for link line stuff?
if(COMMAND cmake_policy)
  cmake_policy(SET CMP0009 NEW)
endif(COMMAND cmake_policy)


if (${CMAKE_VERSION} VERSION_GREATER 2.6.2)
if(COMMAND cmake_policy)
  cmake_policy(SET CMP0011 NEW)
endif(COMMAND cmake_policy)
endif()

# gp_item_default_embedded_path item default_embedded_path_var
#
# Return the path that others should refer to the item by when the item
# is embedded inside a bundle.
#
# Override on a per-project basis by providing a project-specific
# gp_item_default_embedded_path_override function.
#
function(gp_item_default_embedded_path_override item default_embedded_path_var)
  #
  # The assumption here is that all executables in the bundle will be
  # in same-level-directories inside the bundle. The parent directory
  # of an executable inside the bundle should be MacOS or a sibling of
  # MacOS and all embedded paths returned from here will begin with
  # "@executable_path/../" and will work from all executables in all
  # such same-level-directories inside the bundle.
  #

  # By default, embed things right next to the main bundle executable:
  #
  set(path "@executable_path/../../Contents/MacOS")
  #message(STATUS "%%%=> item: ${item}")
  #message(STATUS "%%%=> default_embedded_path_var: ${default_embedded_path_var}")

  set(overridden 0)
  # For Qt Based Plugins for the image formats, the plugins MUST reside in
  # the "PlugIns/imageformats" directory. Since THIS particular project ONLY has
  # the Qt Frameworks AND the plugins the below regex will suffice to separate
  # them from each other. On other projects we could use better logic to
  # put things where they go. Maybe using some "configured" CMake List of libraries
  # then looking through each list for the currect library being fixed up.
  # Embed .dylibs right next to the main bundle executable:
  #
  
  # First look for plugins that have a ".plugin" extension
  if(item MATCHES "\\.plugin$")
    #message(STATUS "Just a Plugin")
    set(path "@executable_path/../Plugins")
    set(overridden 1)
  endif(item MATCHES "\\.plugin$")
  
  # Next look for the Qt Image Format Plugins in case those are needed
  if ( item MATCHES "imageformats/libq?")
    #message(STATUS "^^^^^^==> Qt Image Format Plugin Found")
    set(path "@executable_path/../Plugins/imageformats")
    set(overridden 1)
  # Lastly pick up any plugins that simply have the ".dylib" extension
  elseif(item MATCHES "\\.dylib$")
    #message(STATUS "Dylib that needs fixing")
    set(path "@executable_path/../lib")
    set(overridden 1)
  endif()
  
  # Embed frameworks in the embedded "Frameworks" directory (sibling of MacOS):
  #
  if(NOT overridden)
    if(item MATCHES "[^/]+\\.framework/")
      set(path "@executable_path/../Frameworks")
      set(overridden 1)
    endif(item MATCHES "[^/]+\\.framework/")
  endif(NOT overridden)

  set(${default_embedded_path_var} "${path}" PARENT_SCOPE)
endfunction()


#-- Be sure all the internal directories are created first before calling the 'fixup_bundle'
file(MAKE_DIRECTORY "${CMAKE_INSTALL_PREFIX}/@target@.app/Contents/lib")
file(MAKE_DIRECTORY "${CMAKE_INSTALL_PREFIX}/@target@.app/Contents/plugins")
file(MAKE_DIRECTORY "${CMAKE_INSTALL_PREFIX}/@target@.app/Contents/Frameworks")
file(MAKE_DIRECTORY "${CMAKE_INSTALL_PREFIX}/@target@.app/Contents/Support")

#--------------------------------------------------------------------------------
# Check for Qt4 stuff
if ("@Q_WS_MAC@" STREQUAL "1")
# install a qt.conf file
  file(WRITE "${CMAKE_INSTALL_PREFIX}/@target@.app/Contents/Resources/qt.conf" "")
# Check if we are using Qt Cocoa in which case we need to copy some additional resources
  if ("@QT_MAC_USE_COCOA@" STREQUAL "1")
    message(STATUS "Copying qt_menu.nib into @target@.app/Contents/Resources")
    file(MAKE_DIRECTORY "${CMAKE_INSTALL_PREFIX}/@target@.app/Contents/Resources/qt_menu.nib")
    execute_process(COMMAND ${CMAKE_COMMAND} -E copy_directory "@QT_LIBRARY_DIR@/QtGui.framework/Resources/qt_menu.nib" "${CMAKE_INSTALL_PREFIX}/@target@.app/Contents/Resources/qt_menu.nib")
  endif()

endif()

# --------------------------------------------------------------------
# Copy the Qt Plugins into the proper location of the App package
# This MUST be done BEFORE fixup_bundle is run
set (COMPLETE_PLUGIN_LIST "@PLUGIN_LIST@")
SET (PLUGIN_LIST "")

# --------------------------------------------------------------------
# This loop will look at each plugin and run a simple REGEX to determine if the
# plugin is a Qt based plugin or if the plugin was built as part of the project.
# The reason for the distinction is that we need to manually copy the plugin from
# its current location into its new location inside the App bundle. Qt Plugins
# have specific locations that they MUST be located in. Our own plugins will
# be placed loose in the 'plugins' directory.
foreach(p ${COMPLETE_PLUGIN_LIST})
    #message(STATUS "p: ${p}")
    if(p MATCHES "@QT_PLUGINS_DIR@")
        #message(STATUS "Found Qt Plugin!!!!!!")
        get_filename_component(qt_plugin_name "${p}" NAME)
        get_filename_component(qt_plugin_type_path "${p}" PATH)
        get_filename_component(qt_plugin_type "${qt_plugin_type_path}" NAME)
        file(MAKE_DIRECTORY "${CMAKE_INSTALL_PREFIX}/@target@.app/Contents/plugins/${qt_plugin_type}")
        message(STATUS "Copying Qt Plugin\n    Source: ${p}\n    Destination: ${CMAKE_INSTALL_PREFIX}/@target@.app/Contents/plugins/${qt_plugin_type}")
        execute_process(COMMAND ${CMAKE_COMMAND} -E copy_if_different 
                        "${p}" 
                        "${CMAKE_INSTALL_PREFIX}/@target@.app/Contents/plugins/${qt_plugin_type}/.")
        LIST( APPEND PLUGIN_LIST
                        "${CMAKE_INSTALL_PREFIX}/@target@.app/Contents/plugins/${qt_plugin_type}/${qt_plugin_name}")
    else()
        get_filename_component(plugin_name "${p}" NAME)
        message(STATUS "Copying Plugin\n    Source: ${p}\n    Destination: ${CMAKE_INSTALL_PREFIX}/@target@.app/Contents/plugins/")
        execute_process(COMMAND ${CMAKE_COMMAND} -E copy_if_different 
                        "${p}" 
                        "${CMAKE_INSTALL_PREFIX}/@target@.app/Contents/plugins/.")
        LIST( APPEND PLUGIN_LIST
                        "${CMAKE_INSTALL_PREFIX}/@target@.app/Contents/plugins/${plugin_name}")
    endif()
  
endforeach(p ${PLUGIN_LIST})

# -- Run the BundleUtilities cmake code
include(BundleUtilities)
if (1)
fixup_bundle("${CMAKE_INSTALL_PREFIX}/@target@.app" 
             # Plugins to Install
             "${PLUGIN_LIST}"
             # Directories to Search for Libraries
             "@LIB_SEARCH_DIRS@")
endif()